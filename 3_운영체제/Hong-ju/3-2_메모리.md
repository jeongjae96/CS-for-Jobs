# Cache
- CPU 캐시는 L1 ~ L3까지 존재
- 데이터 처리 속도가 빠른 장치와 상대적으로 느린 장치간 통신에서 병목을 줄이기 위한 역할
- 데이터를 임시로 저장해놓는 공간이기 때문에 같은 데이터를 다시 데이터를 불러오지 않아도 돼 경제성도 있음

## Caching Layer
- 서로 다른 계층간에 통신할 때, 그 계층들 사이에 존재하여 병목을 해결하기 위한 계층
- CPU Cache와 Secondary Memory(보조기억장치) 사이에 존재하는 Primary Memory는 캐싱 계층에 속한다고 할 수 있음

# Locality
- 캐싱 계층을 두는 것 말고, 자주 사용하는 데이터를 기반으로 캐시를 직접 설정할 수 있음
- 이 자주 사용하는 데이터를 선별하기 위한 근거가 Locality(지역성)임

## Temporal Locality(시간 지역성)
- for 문 등에서 여러번 사용되는 변수 `i` 처럼 최근에 접근/사용한 데이터를 다루는 특성

## Spatial Locality(공간 지역성)
- 최근에 접근/사용한 데이터를 이루고 있는 공간 혹은 그 가까운 공간에 접근하는 특성
- 배열 자료구조가 그 예시

# Cache Hit, Cache Miss
- 처리할 데이터를 캐시에서 찾았다면 캐시 히트, 찾지 못하여 메모리에서 불러와야 하는 경우 캐시 미스
- 캐시 히트는 CPU 내부 버스와 내부에 존재하는 캐시 메모리를 사용하므로 높은 처리 속도를 기대할 수 있음
- 캐시 미스는 시스템 버스와 CPU 외부에 존재하는 메모리에 접근하여 데이터를 불러와야 하므로 상대적으로 처리 속도가 낮음

# Cache Mapping
- 캐시 히트율을 높이기 위한 매핑 방법론

## Directed Mapping
- 메모리가 1 ~ 100, 캐시가 1 ~ 10이 있다고 가정하면, 캐시 1은 메모리 1 ~ 10, 캐시 2는 메모리 11 ~ 20, ...
- 처리가 빠르지만 충돌이 잦음

## Associative Mapping
- 순서 일치가 아닌 캐시와 메모리를 연관성을 기반으로 매핑하는 방법
- 충돌이 적지만 모든 블록을 탐색해야 해서 속도가 느림

## Set Associative Mapping
- Directed Mapping과 Associative Mapping을 믹싱한 방법
- 순서를 일치시키지만 집합을 두어서 저장
- 블록화되어 있기 때문에 검색이 상대적으로 효율적임
- 메모리가 1 ~ 100, 캐시가 1 ~ 10이 있다고 가정하면, 캐시 1 ~ 5에는 메모리 1 ~ 50의 데이터를 무작위로 저장시킴

# Web Browser Cache
- 사용자의 커스텀한 정보나 인증 모듈 등을 웹 브라우저에 저장하여 추후 서버에 요청을 보낼 때 사용자 본인의 아이덴티티를 밝히는 일이나 중복 *요청(응답?)* 방지를 위하여 쓰임
- 저장소 쿠키, 로컬 스토리지, 세션 스토리지가 있음

# Web Cookie
- 만료기한이 정해져 있는 Key-Value 데이터 저장소
    - 만료기한은 클라이언트 혹은 서버에서 직접 설정 가능
    - 일반적으로는 서버가 결정
- `same site` 옵션을 `strict`로 설정하지 않았을 경우, 다른 도메인에서 요청 시 자동으로 전송
- 최대 크기 4KB
- \[보안 이슈\] document.cookie로 쿠키 내부를 볼 수 없게 httponly 옵션 부여하는 것이 중요!

# Local Storage
- **만료기한이 없는** Key-Value 데이터 저장소
- 브라우저를 닫아도(= 탭을 닫아도?) 유지됨
- 최대 크기 10MB
- 도메인 단위로 저장 및 생성
- `HTML5`를 지원하지 않는 웹 브라우저는 사용할 수 없음
- 클라이언트만 수정할 수 있음

# Session Storage
- **만료기한이 없는** Key-Value 데이터 저장소
- 탭을 닫을 때 해당 데이터가 삭제
- 최대 크기 5MB
- 역시 `HTML5`를 지원하지 않는 웹 브라우저는 사용할 수 없음
- 역시 클라이언트만 수정할 수 있음

# Database Caching Layer
- 애플리케이션과 메인 데이터베이스 사이에 `Redis`와 같은 DB를 두어 캐싱 계층을 두기도 함
- 캐시 히트: 레디스에서 데이터 읽어옴
- 캐시 미스: 메인 DB에서 데이터 읽어옴

# Swapping
- Primary Memory에 당장 사용하지 않는 데이터들을 Secondary Storage로 옮기고 Secondary Storage의 데이터를 Primary Memory로 불러와 쓰는 기법
- Logical Address에는 있는데 Physical Address에는 없는 데이터에 접근할 때 발생하는 Page Fault를 해결하기 위한 기법

# Page Fault Workflow
1. CPU가 Physical Memory에서 작업에 필요한 페이지가 없으면 트랩을 발생시켜 OS에게 알림
1. OS는 CPU의 동작을 잠시 멈춤
1. OS는 페이지 테이블을 확인하여 Virtual Memory에 해당 페이지가 존재하는지 확인
1. 페이지가 없다면 프로세스를 중단하고, 현재 Phyical Memory에 비어 있는 프레임이 있는지 확인
1. Physical Memory에도 없다면 스와핑이 발동
1. 비어 있는 프레임에 해당 페이지를 로드하고, 페이지 테이블 최신화
1. CPU 동작 재개

# 최소 크기 단위
- Page: 가상 메모리에서 사용하는 최소 크기 단위
- Frame: 실제 메모리를 사용하는 최소 크기 단위

# Thrashing
- 메모리의 Page Fault Rate가 높은 상황을 뜻함
- 다수의 인터럽트로 CPU 이용률이 떨어지는 현상
- CPU 자원을 효율적으로 사용하지 못하면 심각한 성능 저하를 초래할 수 있음
- 너무 많은 프로세스가 동시에 올라가면 발생하기 쉬움
- CPU 이용률이 낮아지면 OS는 더 많은 프로세스를 메모리에 로드하게 됨, 악순환
- 메모리를 늘리거나, Secondary Memory를 SSD 등으로 업그레이드하여 해결할 수 있음

## Working Set
- Thrashing을 해결하기 위한 2가지 기법 중 하나
- 프로세스의 Locality를 통해 페이지 집합을 결정하고, 이를 미리 메모리에 로드하는 것
- 페이지 탐색 비용과 스와핑을 줄일 수 있음

## Page Fault Frequency
- Page Fault의 빈도를 상한과 하한을 만들어 조절하는 방법
- 상한에 도달하면 프레임을 늘리고, 하한에 도달하면 프레임을 줄임

# 메모리 할당
- 메모리에 프로그램을 할당할 때, 시작 메모리의 위치와 메모리의 할당 크기로 할당함
- 연속 할당과 불연속 할당으로 나뉨

## 연속 할당
- 메모리에 연속/순차적으로 공간을 할당하는 것
- 2가지의 메모리 분할 방식이 있음

### Fixed Partition Allocation (고정 분할 방식)
- 메모리를 미리 나누어 관리하는 방식
- 상황에 따라 나눈 게 아니라 미리 나누어 놓은 방식이기 때문에 비효율적일 수 있음
- 내부 단편화 문제 발생 가능

### Variable Partition Allocation (가변 분할 방식)
- 매 시점 프로그램의 크기에 맞게 동적으로 메모리를 나눠 사용
- 내부 단편화 문제가 아닌 외부 단편화 문제 발생 가능

### 내부/외부 단편화 (Internat/External Fragmentation)
- 내부: 나눈 메모리 크기보다 프로그램의 크기가 작아서 들어가지 못하는 공간이 많이 발생하는 현상
- 외부: 나눈 메모리 크기보다 프로그램의 크기가 커서 들어가지 못하는 공간이 많이 발생하는 현상

### First-fit
- 위 혹은 아래쪽부터 탐색하면서 Hole을 찾으면 바로 할당
- Hole: 할당할 수 있는 비어 있는 메모리 공간

### Best-fit
- 프로세스의 크기 이상인 공간 중 가장 작은 홀부터 할당

### Worst-fit
- 프로세스의 크기와 가장 차이가 많이 나는 홀에 할당

## 불연속 할당
- 메모리를 연속적으로 할당하지 않는 방식
- 현대적인 OS들이 사용하는 방식
- 메모리를 동일한 크기의 페이지(일반적으로 4KB)로 나누고, 프로그램마다 페이지 테이블을 두어서 이를 통해 메모리에 프로그램을 할당하는 것

### Paging
- 동일한 크기의 페이지 단위로 나누어 메모리의 서로 다른 위치에 프로세스를 할당
- Hole의 크기가 균일하지 않은 문제가 없어지지만, 주소 변환이 복잡해짐

### Segmentation
- 페이지가 아니고, 의미 단위인 세그먼트로 나누는 방식
- 코드, 데이터, 스택, 힙 등을 기반으로 프로세스를 나누어 관리
- 공유와 보안 측면에서 우수
- 단, Hole의 크기가 균일하지 않은 문제가 발생

### Paged Segmentation
- 공유나 보안을 세그먼트로 나누고, Physical Memory는 페이지로 나누는 것

## Last Recently Used Algorithm
- 페이지 교체 알고리즘 중 하나
- 해시 테이블로 탐색하고, Double Linked List로 데이터를 담음
- Implemantation Example
```cpp
void LRUCache::refer(int x) {
    if (hash.find(x) == hash.end()) {
        if (li.size() = csize) {  // Cache size
            // 가장 끝에 있는 것을 뽑아낸다. 이는 가장 오래된 것을 의미
            int last = li.back();

            li.pop_back();
            hash.erase(last); 
        }
    } else {
        li.erase(hash[x]); 
    }
    
    // 해당 페이지를 참조할 때 가장 앞에 붙인다. 또한, 이를 해시 테이블에 저장
    li.push_front(x);
    hash[x] = li.begin(); 
}
```
