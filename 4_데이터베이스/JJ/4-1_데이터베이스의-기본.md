# 데이터베이스의 기본

- 데이터베이스: 일정한 규칙, 혹은 규약을 통해 구조화되어 저장되는 데이터의 모음.
- 해당 데이터베이스를 제어, 관리하는 통합 시스템을 DBMS(DataBase Management System)이라고 한다.
- 데이터베이스 안에 있는 데이터들은 특정 DBMS마다 정의된 쿼리 언어(query language)를 통해 삽입, 삭제, 수정, 조회 등을 수행할 수 있다.
- 데이터베이스는 실시간 접근과 동시 공유가 가능하다.
- 예시: MySQL이라는 DBMS 위에 응용 프로그램에 속하는 Node.js나 php에서 해당 데이터베이스 안에 있는 데이터를 꺼내 해당 데이터 관련 로직을 구축할 수 있다.

## 엔터티(entity)

- 엔터티: 사람, 장소, 물건, 사건, 개념 등 여러 개의 속성을 지닌 명사를 의미.
  - e.g. 회원이라는 엔터티는 이름, 아이디, 주소, 전화번호 등의 속성을 갖을 수 있다.
- 서비스의 요구 사항에 맞춰 속성이 정해진다.

약한 엔터티와 강한 엔터티

- A가 혼자서는 존재하지 못하고 B의 존재 여부에 종속적이라면 A는 약한 엔터티, B는 강한 엔터티이다.
  - e.g. 방은 건물 안에만 존재하기 때문에 약한 엔터티, 건물은 강한 엔터티라고 할 수 있다. 

## 릴레이션(relation)

- 릴레이션: 데이터베이스에서 정보를 구분하여 저장하는 기본 단위.
- 엔터티에 관한 데이터를 데이터베이스는 릴레이션 하나에 담아서 관리한다.

![image](https://github.com/yi-hongju/CS-for-Jobs/assets/44770369/03948291-69e6-47c8-9630-214b0fae1f86)

- 앞의 그림과 같이 회원이라는 엔터티가 데이터베이스에서 관리될 때, 릴레이션으로 변화된다.
- 릴레이션은 관계형 데이터베이스에서는 ```테이블```이라고 한다.
- NoSQL 데이터베이스에서는 ```컬렉션```이라고 한다.

테이블과 컬렉션

- 데이터베이스의 종류는 크게 관계형 데이터베이스와 NoSQL 데이터베이스로 나눌 수 있다.
- 대표적인 관계형 데이터베이스로는 MySQL, NoSQL 데이터베이스는 MongoDB가 있다.
- MySQL의 구조는 레코드-테이블-데이터베이스로 이루어져 있다.
- MongoDB 데이터베이스의 구조는 도큐먼트-컬렉션-데이터베이스로 이루어져 있다.

![image](https://github.com/yi-hongju/CS-for-Jobs/assets/44770369/1e8a955d-948e-4f3a-aec2-0bf5764e8474)

- 위의 그림과 같이 레코드-테이블-데이터베이스의 구조에서는 레코드가 쌓여 테이블이 되고, 테이블이 쌓여 데이터베이스가 된다.

## 속성(attribute)

- 릴레이션에서 관리하는 구체적이며 고유한 이름을 갖는 정보.
- 서비스의 요구 사항을 기반으로 관리해야 할 필요가 있는 속성들만 엔터티의 속성이 된다.

## 도메인(domain)

- 도메인: 릴레이션에 포함된 각각의 속성들이 가질 수 있는 값의 ```집합```을 말한다.
- 예를 들어 성별이라는 속성이 있다면, 이 속성이 가질 수 있는 값은 {남, 여}라는 집합이 된다.

## 필드와 레코드

![image](https://github.com/yi-hongju/CS-for-Jobs/assets/44770369/fa27ba42-36f4-4ca3-9c8d-3101b454daca)

회원이란 엔터티는 member라는 ```테이블```로 ```속성```인 이름, 아이디 등을 가지고 있으며 name, ID, address 등의 ```필드```를 가진다. 그리고 이 테이블에 쌓이는 행(row) 단위의 데이터를 ```레코드```라고 한다. 또한, 레코드를 ```튜플```이라고도 한다.

예시로 책이라는 엔터티를 정의하고 이를 기반으로 테이블을 만들어 보자. 먼저 속성들로 제목, 가격, ISBN, 저자, 출판년도 등이 있을 것이다. 이 속성 중에서 책의 이름, 저자의 아이디, 출판년도, 장르, 생성 일시, 업데이트 일시만 있다고 해보자.

이 엔터티를 데이터베이스에 넣어 테이블로 만드려면, 속성에 맞는 타입을 정의해야 한다. 타입은 MongoDB, MySQL 등 데이터베이스마다 조금씩 차이가 있다. MySQL을 기준으로 설명을 하겠다.

- 책의 아이디: INT
- 책의 제목: VARCHAR(255)
- 책의 저자 아이디: INT
- 책의 출판년도: VARCHAR(255)
- 책의 장르: VARCHAR(255)
- 생성 일시: DATETIME
- 업데이트 일시: DATETIME

각 속성에 맞는 타입을 정의를 하고, 테이블로 만들면 다음과 같다.

![image](https://github.com/yi-hongju/CS-for-Jobs/assets/44770369/39ec25f7-bc09-4895-aae7-340fa4249cfa)

보통 한글을 속성 이름으로 사용하지 않고, 영어 이름에 매핑해서 사용한다.

앞의 테이블을 MySQL로 구현하려면, 다음 코드를 입력하면 된다.

```sql
CREATE TABLE book(
    id INT NOT NULL AUTO_INCREMENT,
    title VARCHAR(255),
    author_id INT,
    publishing_year VARCHAR(255),
    genre VARCHAR(255),
    created_at DATETIME,
    updated_at DATETIME,
    PRIMARY KEY (id)
);
```

### 필드 타입

- 필드는 숫자, 날짜, 문자와 같은 타입을 갖는다. MySQL을 기준으로 설명할 예정이다.

숫자 타입

- 숫자 타입으로는 TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT 등이 있다.

| 타입  | 용량(바이트) | 최솟값(부호 있음) | 최솟값(부호 없음) | 최댓값(부호 없음) | 최댓값(부호 있음) |
| ------------- | ------------- | ------------- | ------------- | ------------- | ------------- |
| TINYINT | 1  | -128  | 0  | 127  | 255  |
| SMALLINT  | 2  | -32768  | 0  | 32767  | 65535  |
| MEDIUMINT  | 3  | -8388608  | 0  | 8388607  | 16777215  |
| INT  | 4  | -2147483648  | 0  | 2147483647  | 4294967295  |
| BIGINT  | 8  | -2^63  | 0  | 2^63 - 1  | 2^64 - 1  |

날짜 타입

- 날짜 타입으로는 DATE, DATETIME, TIMESTAMP 등이 있다.
- DATE: 날짜 부분은 있지만 시간 부분은 없는 값에 사용. 지원되는 범위는 1000-01-01~9999-12-31이다. 3바이틔 용량을 가진다.
- DATETIME: 날짜 및 시간 부분을 모두 포함하는 값에 사용. 지원되는 범위는 1000-01-01 00:00:00에서 9999-12-31 23:59:59이다. 8바이트의 용량을 가진다.
- TIMESTAMP: 날짜 및 시간 부분을 모두 포함하는 값에 사용. 1970-01-01 00:00:01에서 2038-01-19 03:14:07까지 지원한다. 4바이트의 용량을 가진다.

[[MySQL] TIMESTAMP 타입과 DATETIME 타입의 차이](https://jaejade.tistory.com/125)

문자 타입

- 문자 타입으로는 CHAR, VARCHAR, TEXT, BLOB, ENUM, SET 등이 있다.

CHAR와 VARCHAR

- CHAR 또는 VARCHAR 모두 그 안에 수를 입력해 몇 자까지 입력할지 정한다. 예를 들어, CHAR(30)이라면 최대 30글자까지 입력할 수 있다.
- CHAR는 고정 길이 문자열이며 길이는 0에서 255 사이의 값을 가진다. 레코드를 저장할 때 무조건 선언한 길이 값으로 ‘고정’해서 저장된다. 예를 들어 CHAR(100)으로 선언한 후 10글자를 저장해도 100바이트로 저장되게 된다.
- VARCHAR는 가변 길이 문자열이다. 길이는 0에서 65,535 사이의 값으로 지정할 수 있으며, 입력된 데이터에 따라 용량을 가변시켜 저장한다. 예를 들어, VARCHAR(10000)으로 선언하고 10글자의 이메일을 저장할 경우, 10글자에 해당하는 바이트 + 길이기록용 1바이트로 저장하게 된다.
- CHAR의 경우 유동적이지 않은 길이를 가진 데이터의 경우 효율적이다.
- 유동적인 길이를 가진 데이터는 VARCHAR로 저장하는 것이 좋다.

TEXT와 BLOB

- 두 개의 타입 모두 큰 데이터를 저장할 때 쓰는 타입이다.
- TEXT는 큰 문자열 저장에 쓰며, 주로 게시판의 본문을 저장할 때 쓴다.
- BLOB은 이미지, 동영상 등 큰 데이터 저장에 쓴다. 그러나 보통은 아마존의 이미지 호스팅 서비스인 S3를 이용하는 등 서버에 파일을 올리고 파일에 관한 경로를 VARCHAR로 저장한다.

ENUM과 SET

- ENUM과 SET 모두 문자열을 열거한 타입이다.
- ENUM은 ENUM('x-small', 'small', 'medium', 'large', 'x-large') 형태로 쓰이며, 이 중에서 하나만 선택하는 단일 선택만 가능하고 ENUM 리스트에 없는 잘못된 값을 삽입하면 빈 문자열이 대신 삽입된다. ENUM을 이용하면 x-small 등이 0, 1 등으로 매핑되어 메모리를 적게 사용하는 이점을 얻는다. ENUM은 최대 65,535개의 요소들을 넣을 수 있다.
- SET은 여러 개의 데이터를 선택할 수 있고, 비트 단위의 연산을 할 수 있으며, 최대 64개의 요소를 넣을 수 있다.
- ENUM이나 SET을 사용할 경우, 공간적으로 이점을 볼 수 있지만, 애플리케이션의 수정에 따라 데이터베이스의 ENUM이나 SET에서 정의한 목록을 수정해야 한다는 단점이 있다.

## 관계

- 데이터베이스에서 테이블은 하나만 있지 않다.
- 여러 개의 테이블은 서로의 관계가 정의되어 있다.
- 관계를 관계화살표로 나타낼 수 있다.

![image](https://github.com/yi-hongju/CS-for-Jobs/assets/44770369/e1566a5e-2e76-4722-8a85-a9868b157e3f)

1:1 관계

- 유저당 유저 이메일이 한 개씩 있다면, 1:1 관계가 된다.

![image](https://github.com/yi-hongju/CS-for-Jobs/assets/44770369/7a852e99-4051-4e79-8df5-cccabbe21f99)

1:N 관계

- 쇼핑 시, 한 유저당 여러 개의 상품을 장바구니에 넣을 수 있다. 이 경우 1:N 관계가 된다.
- 하나도 넣지 않는 0개의 경우도 있으니 0도 포함되는 화살표를 통해 표현해야 한다.

![image](https://github.com/yi-hongju/CS-for-Jobs/assets/44770369/3523eb7e-2952-4a65-9396-1561f20fc063)

N:M 관계

- 학생과 강의의 관계에서는 학생도 강의를 많이 들을 수 있고, 강의도 여러 명의 학생을 포함할 수 있다. 이 경우 N:M이 된다.

![image](https://github.com/yi-hongju/CS-for-Jobs/assets/44770369/f4487240-cf68-4db8-a047-821b2bb5ddd6)

- N:M은 테이블 두 개를 직접적으로 연결해서 구착하지 않고 1:N, 1:M이라는 관계를 갖는 테이블 두 개로 나누어서 설정한다.

## 키

- 테이블 간의 관계를 조금 더 명확하게 하고, 테이블 자체의 인덱스를 위해 설정된 장치로 기본키, 외래키, 후보키, 슈퍼키, 대체키가 있다.

![image](https://github.com/yi-hongju/CS-for-Jobs/assets/44770369/bc1e83a2-5082-4d52-9864-3ead1777de03)

- 슈퍼키는 유일성이 있고, 그 안에 포함된 후보키는 최소성까지 갖춘 키이다.
- 후보키 중에서 기본키로 선택되지 못한 키는 대체키가 된다.
- 유일성은 중복되는 값은 없으며, 최소성은 필드를 조합하지 않고 최소 필드만 써서 키를 형성할 수 있는 것을 말한다.

기본키(Primary Key)

- 기본키는 줄여 PK 또는 프라이머리키라고 많이 부른다.
- 유일성과 최소성을 만족하는 키이다.
- 테이블의 데이터 중 고유하게 존재하는 속성이며 기본키에 해당하는 데이터는 중복되어서는 안 된다.
- {ID, name}이라는 복합키를 기본키로 설정한다면 최소성을 만족하지 않는다.
- 기본키는 자연키 또는 인조키 중에 골라 설정한다.
- 자연키: 유저 테이블을 만든다고 가정하면 주민등록번호, 이름, 성별 등의 속성이 있다. 이 중 이름, 성별 등은 중복된 값이 들어올 수 있으므로 부적절하고 남는 것은 주민등록번호이다. 이런 식으로 중복된 값들을 제외하고 중복되지 않는 것을 자연스레 뽑다가 나오는 키를 자연키라고 한다.
- 인조키: 인위적으로 유저 아이디를 부여한다. 이를 통해 고유 식별자가 생겨난다. 오라클은 sequence, MySQL은 auto increment 등으로 설정한다. 

외래키(Foreign Key)

- FK라고도 하며, 다른 테이블의 기본키를 그대로 참조하는 값으로 개체와의 관계를 식별하는데 사용한다.

![image](https://github.com/yi-hongju/CS-for-Jobs/assets/44770369/57e63249-84e4-4cb8-a388-3549b10765a2)

- 외래키는 중복되어도 괜찮다.

후보키(candidate key)

- 기본키가 될 수 있는 후보들이며 유일성과 최소성을 동시에 만족하는 키이다.

대체키(alternative key)

- 후보키가 두 개 이상일 경우, 어느 하나를 기본키로 지정하고 남은 후보키들을 말한다.

슈퍼키(super key)

- 각 레코드를 유일하게 식별할 수 있는 유일성을 갖춘 키.