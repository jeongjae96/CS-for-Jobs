# 인덱스

## 인덱스의 필요성

- 인덱스는 데이터를 빠르게 찾을 수 있는 하나의 장치이다.

## B-트리

- 인덱스는 보통 B-트리라는 자료 구조로 이루어져 있다.
- B-트리는 루트 노드, 리프 노드, (루트 노드와 리프 노드 사이에 있는) 브랜치 노드로 나뉜다.

<img width="512" alt="image" src="https://github.com/yi-hongju/CS-for-Jobs/assets/44770369/84b83794-4c19-49c7-8fa4-146be0247e81">

<img width="800" alt="image" src="https://github.com/yi-hongju/CS-for-Jobs/assets/44770369/266e65ad-6214-4bd8-856e-7e21a993e0ba">

인덱스가 효율적인 이유와 대수확장성

- 인덱스가 효율적인 이뉴는 효율적인 단계를 거쳐 모든 요소에 접근할 수 있는 규형 잡힌 트리 구조와 트리 깊이의 대소확장성 때문이다.
- 대소확장성이란 트리 깊이가 리프 노드 수에 비해 매우 느리게 성장하는 것을 의미한다.
- 기본적으로 인덱스가 한 깊이씩 증가할 때마다 최대 인덱스 항목의 수는 4배씩 증가한다.

<img width="224" alt="image" src="https://github.com/yi-hongju/CS-for-Jobs/assets/44770369/d85ea4f3-badc-4faf-babf-517820d00633">

- 위의 표처럼 깊이가 10인 트리로, 100만 개의 레코드를 검색할 수 있다.
- 실제 인덱스는 이것보다 훨씬 효율적이다.

## 인덱스 만드는 방법

MySQL

- 클러스터형 인덱스와 세컨더리 인덱스가 있다.
- 클러스터형 인덱스는 테이블당 하나를 설정할 수 있다.
- primary key 옵션으로 기본키를 만들면 클러스터형 인덱스를 생성할 수 있다.
- 기본키로 만들지 않고 unique not null 옵션을 붙이면 클러스터형 인덱스로 만들 수 있다.
- create index ... 명령어를 기반으로 만들면 세컨더리 인덱스를 만들 수 있다.
- 하나의 인덱스만 생성할 것이라면 클러스터형 인덱스를 만드는 것이 성능이 좋다.
- 세컨더리 인덱스는 보조 인덱스로 여러 개의 필드 값을 기반으로 쿼리를 많이 보낼 때 생성해야 하는 인덱스이다. 
- 예로, age라는 하나의 필드만으로 쿼리를 보낸다면 클러스터형 인덱스만 필요하고, age, name, email 등 다양한 필드를 기반으로 쿼리를 보낼 때는 세컨더리 인덱스를 사용해야 한다.

MongoDB

- 도큐먼트를 만들면 자동으로 ObjectID가 형성되며, 해당 키가 기본키로 설정된다.
- 세컨더리키도 부가적으로 설정해서 기본키와 세컨더리키를 같이 쓰는 복합 인덱스를 설정할 수 있다.

## 인덱스 최적화 기법

- 데이터베이스마다 조금씩 다르지만, 기본적인 골조는 똑같다.
- MongoDB를 기반으로 최적화 기법을 설명할 예정이다.